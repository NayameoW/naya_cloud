# 8.1 图和图遍历
给定图$G=(V, E)$，V是顶点集，边集$E \subseteq V \times V$表示顶点之间的某种二元关系。如果$E$是一种对称关系，则称图$G$为无向图；如果$E$是非对称关系，则称$G$为无向图。
用于图表示的数据结构主要有两种，一种是邻接链表，一种是邻接矩阵。
图遍历是对图的一种最基本但也是最重要的处理，它遵循节点之间的关联关系，按某种顺序依次处理图中所有的点和边。

# 8.2 有向图上的深度优先遍历
基本思想：从一个节点出发，如果它有未探索的邻居节点，则选择其中的某一个深入探索（其他可探索的节点暂时不管），每到一个新的节点则递归地进行上述深入探索的过程。当探索无法继续时，则沿着探索的路径回退。此时该节点可能还有其他邻居节点未被探索过，需要递归地对该邻居节点进行深入探索。

## 8.2.1 遍历框架
在遍历过程中一个节点会经历三种不同的状态，遍历算法将这三种状态标记为三种颜色：
- 白色：表示一个节点尚未被遍历到。
- 灰色：表示一个节点已经被遍历到，但是对于它的遍历尚未结束。这是因为根据深度优先遍历的规则，该节点还有若干邻居节点尚未遍历，当前算法正在递归地深入探索该节点地某个邻居节点。
- 黑色：表示一个节点的所有邻居节点已经完成遍历，其自身的遍历也已经结束。
## 8.2.2 深度优先遍历树
由于图的一条边唯一地由它地一对顶点确定，因而考察一条边的两个顶点的状态变化组合时，可以进一步对边的状态做更细致的分类。深度优先的遍历过程将边分为四种类型：Tree Edge、Back Edge、Descendant Edge、Cross Edge。

## 8.2.3 活动区间
**Thm 8.1**  考察深度优先遍历图$G=(V, E)$的过程。对任意点$v$和$w$：
- $w$是$v$在DFS树中的后继节点，当且仅当$active(w) \subseteq active(v)$。若$w \ne v$，则此处的包含为真包含
- $w$和$v$没有祖先后继关系，当且仅当$active(w)$和$active(v)$没有重叠。
- 如果$vw$是图$G$中的边，则
	- $vw$是CE，当且仅当$active(w)$在$active(v)$前面。
	- $vw$是DE，当且仅当存在第三个节点$x$满足：$active(w) \subset active(x) \subset active(v)$。
	- $vw$是TE，当且仅当$active(w) \subset active(v)$，且不存在第三个节点$x$满足：$active(w) \subset active(x) \subset active(v)$。
	- $vw$是BE，当且仅当$active(v) \subset active(w)$。

> 基于此定理，可以将图遍历活动间的时序关系等价地转换成整数区间之间的先后/包含关系。

Thm 8.2（白色路径定理）  在深度优先遍历树中，节点$v$是$w$的祖先，当且仅当在遍历过程中刚刚发现$v$的时刻，存在一条从$v$到$w$的全部由白色节点组成的路径。
# 8.3 有向图上深度优先遍历的应用
## 8.3.1 拓扑排序
**Def 8.2（拓扑排序）**  如果为图中每个顶点 $v_1, v_2, \dots , v_n$ 分配一个序号 $\tau_1, \tau_2 ,\dots , \tau_n$ 满足：
- 所有序号为正整数1到n的某个排列（理论上是全序集即可）
- 对任意有向边$i \to j$（从$v_i$指向$v_j$的有向边），满足 $\tau_i \lt \tau_j$
则 $\tau_1, \tau_2 ,\dots , \tau_n$ 为图$G$中顶点 $v_1, v_2, \dots , v_n$ 的一个拓扑排序。（若要求 $\tau_i \lt \tau_j$ 则成为逆拓扑排序）。

> 拓扑排序只限制有向边的两个节点上序号的大小关系，通过传递性来保证整个图上的“拓扑关系”。

**Lemma 8.1**  如果有向图 $G=(V, E)$ 中有环，则图$G$不存在拓扑排序。
> 反证可推出环上任意节点的拓扑序号都严格大于自身。
> 此引理揭示了有向图中环的存在性与拓扑排序的存在性之间的重要关联。

**Lemma 8.2**  如果有向图 $G=(V, E)$ 为有向无环图，则图$G$必然存在拓扑排序。

**Thm 8.3**  图$G$是有向无环图，当且仅当图$G$有拓扑排序。

## 8.3.2 关键路径
拓扑排序关注的是一类简单的调度问题，即主要考虑任务之间的依赖关系，在保证依赖关系的前提下所有任务串行执行。以此为基础可以变得更加复杂。例如考虑有多台机器并行、每个任务有自己的执行时长等等。任务调度的目标是让所有任务尽早执行完。

**Def 8.3（最早开始时间、最早结束时间的递归定义）**
- 如果一个任务$a_i$不依赖任何其他任务，则$est_i=0$
- 如果一个任务$a_i$的$est_i$已经被确定，则$eft_i=est_i + l_i$
- 如果一个任务$a_i$依赖若干其他任务，则$est_i$为它所依赖的所有任务的最早结束时间中的最大值：$est_i = max \{ eft_j \mid a_i \to a_j \}$

**Def 8.4（关键路径）**  任务调度中的关键路径是一组任务 $v_0, v_1, \dots, v_k$ 满足：
- 任务$v_0$不依赖其他任何任务
- 对任意$1 \le i \le k:$ $v_i\to v_{i - 1}, est_i = eft_{i - 1}$
- 任务$v_k$的最早结束时间是所有任务的最早结束时间中最大的

> 关键路径决定所有任务全部处理完毕所需的最少时间。
> 最早开始时间和最早结束时间的递归定义，决定了它们和有向图中逻辑尽头的概念紧密关联。

## 8.3.3 有向图中的强连通片



# 8.4 无向图上深度优先遍历


# 8.5 无向图上深度优先遍历的应用


