## 开放性问题 ：谈谈你知道的 linux
Linux 是一种自由和开放源代码的类 Unix 操作系统。它的内核由芬兰的林纳斯·托瓦兹（Linus Torvalds）在 1991 年开始编写，最初是为他的个人电脑而开发的。Linux 内核的源代码是自由和开放的，任何人都可以获取、使用、修改和分发。
Linux有许多不同的发行版，也称为“发行版”或“发行版”，这是指基于Linux内核的完整操作系统。一些最流行的Linux发行版包括Ubuntu、Debian、Fedora、Red Hat Enterprise Linux、CentOS、Arch Linux等。
Linux系统支持许多不同的协议，包括TCP/IP、SSH、FTP、HTTP、SMTP、POP3等。其中TCP/IP协议是Linux系统中最重要的协议之一，它是Internet上的主要通信协议，用于在计算机之间传输数据。SSH协议是一种安全的远程登录协议，它允许用户通过Internet连接到远程计算机，以便在远程计算机上执行命令。FTP协议是一种用于文件传输的协议，它允许用户在计算机之间传输文件。HTTP协议是Web浏览器和Web服务器之间的主要通信协议，它允许用户在Web上访问和浏览网页。SMTP和POP3协议是用于电子邮件的协议，SMTP协议用于发送电子邮件，而POP3协议用于接收电子邮件。

## 分区形式 ：MBR GPT
MBR（Master Boot Record）是硬盘的一小段特殊区域，用于记录硬盘的分区信息和引导程序（boot loader）。MBR 的结构如下：
1.  引导代码区（Boot Code Area）：占446字节，存放主引导程序。
2.  分区表（Partition Table）：占64字节，用于记录硬盘分区信息。每个分区信息占用16个字节，其中包括起始扇区、分区大小、分区类型等信息。
3.  结束标志（MBR Signature）：占2字节，标识MBR的结束，固定为0x55AA。
MBR的分区表中最多可以记录4个分区，其中3个是主分区，另外一个可以是扩展分区。如果需要更多的分区，就需要使用扩展分区和逻辑分区的结构。
需要注意的是，MBR 是一种旧的分区表格式，在现代硬盘中已经逐渐被 GPT（GUID Partition Table）所取代。

GPT（GUID Partition Table）是一种新的硬盘分区表格式，相较于 MBR 有更多的优势，如支持更大的硬盘容量、更多的分区数量、更安全的数据保护等。GPT 的结构如下：
1.  保护MBR（Protective MBR）：占512字节，用于向不支持GPT的旧系统展示一个虚假的MBR，以保护GPT数据不被修改。
2.  主GPT头（Primary GPT Header）：占92字节，用于记录GPT的基本信息，如分区表的位置、大小、校验和等。
3.  分区表（Partition Table）：占128个条目，每个条目占用128字节，用于记录硬盘分区信息。每个分区信息包括起始扇区、分区大小、分区类型等信息。
4.  备份GPT头（Backup GPT Header）：占92字节，与主GPT头相同，用于备份。
5.  结束标志（GPT Signature）：占8字节，标识GPT的结束，固定为"EFI PART"。
需要注意的是，GPT 需要使用 UEFI（Unified Extensible Firmware Interface）来启动操作系统，因此需要支持 UEFI 的硬件和操作系统才能使用 GPT 格式的硬盘。同时，GPT 也可以被用于其他存储设备，如 U 盘等。

## GRUB
GRUB（GRand Unified Bootloader）是一种常用的多操作系统引导程序，可以让用户在启动计算机时选择要启动的操作系统或内核。
GRUB最初是为GNU项目开发的，但现在已经成为了Linux和其他许多开放源代码操作系统的标准引导程序。它可以识别多种文件系统格式和操作系统类型，包括Linux、Windows、macOS等，可以在同一台计算机上安装多个操作系统，并且可以在不同的分区或磁盘上安装。
GRUB的主要作用是在启动时加载内核，使计算机可以正常启动操作系统。它支持通过菜单选择要启动的操作系统或内核，并提供了许多高级选项来管理启动过程。例如，可以使用GRUB编辑器修改启动选项、添加新的操作系统、修复引导问题等。
GRUB有两个版本：GRUB Legacy和GRUB 2。GRUB Legacy是早期的版本，现已不再维护；GRUB 2是目前广泛使用的版本，支持更多的文件系统格式和功能，例如模块化加载、自动检测操作系统等。

## 编译开源软件流程
### Cmake
1.  编写 CMakeLists. txt 文件：CMakeLists. txt 文件是一个 CMake 脚本，描述了如何构建软件。CMakeLists. txt 文件通常包括以下内容：
-   指定需要编译的源代码文件和头文件。
-   指定需要链接的库文件和头文件。
-   定义编译选项和编译器选项。
-   定义安装目录和安装文件。
-   定义测试目标和测试脚本。
2.  创建构建目录：在源代码目录外创建一个新目录，通常称为构建目录。在构建目录中运行cmake命令来生成Makefile。
3.  配置：运行 cmake 命令时，可以设置一些选项来控制构建过程。例如，可以设置安装路径、开启或关闭某些功能、选择编译器等。cmake 命令通常需要指定源代码目录和构建目录，例如：
```
cmake /path/to/source -DCMAKE_INSTALL_PREFIX=/path/to/install
```
4.  编译：运行 make 命令来编译源代码。make 会根据 Makefile 中的指令来编译源代码，并生成可执行文件或库文件。make 命令通常需要指定并行编译的线程数，例如：
```
make -j4
```
5.  安装：运行make install命令来安装编译后的软件。make install会将可执行文件、库文件、配置文件、文档等安装到指定的目录中。make install命令通常需要使用sudo权限，例如：
```
sudo make install
```

### Automake
1.  编写 configure. ac 文件：configure. ac 文件是一个 autoconf 脚本，描述了如何配置和构建软件。configure. ac 文件通常包括以下内容：
-   检查编译器和系统环境，例如检查头文件、库文件、依赖项等。
-   定义编译选项和编译器选项。
-   定义安装目录和安装文件。
-   定义测试目标和测试脚本。
2.  创建Makefile.am文件：Makefile.am文件是一个automake脚本，描述了如何构建该目录下的源代码。Makefile.am文件通常包括以下内容：
-   定义源代码文件和头文件。
-   定义需要链接的库文件和头文件。
-   定义编译选项和编译器选项。
-   定义安装目录和安装文件。
3.  运行autoreconf命令：在源代码目录中运行autoreconf命令，该命令会根据configure.ac和Makefile.am生成configure脚本、Makefile.in文件和其他必要的文件。例如：
```
autoreconf -i
```
4.  运行configure脚本：在源代码目录中运行configure脚本，该脚本会检查系统和编译器环境，并生成Makefile。configure脚本通常需要指定安装路径，例如：
```
./configure --prefix=/path/to/install
```
5.  编译：运行make命令来编译源代码。make会根据Makefile中的指令来编译源代码，并生成可执行文件或库文件。make命令通常需要指定并行编译的线程数，例如：
```
make -j4
```
6.  安装：运行make install命令来安装编译后的软件。make install会将可执行文件、库文件、配置文件、文档等安装到指定的目录中。make install命令通常需要使用sudo权限，例如：
```
sudo make in
stall
```


## 基本命令
会在各种题目里出现，命令的参数也需要掌握
1. passwd：更改密码
2. mkpasswd：生成随机密码
3. date，cal：找出今天的日期并显示日历
4. who，finger：找出谁在系统上处于活动状态
5. clear：清除屏幕
6. echo：在屏幕上写一条消息
7. write、fall、talk、mesg
  1.  write：给其他用户发信息
  2.  wall：write all给所有登录到系统的用户发信息
  3.  talk：建立聊天session
  4.  mesg：可以屏蔽用户发来的信息

1. 与目录一起使用的命令：
	1. pwd：打印工作目录
	2. cd：更改目录
	3. mkdir：创建目录
	4. rmdir：删除目录
	5. ls：列出目录的内容，-l，-a，-R(递归打印所有的子目录中的文件)选项
2. 与文件一起使用的命令：
    1. touch：更新文件的访问和/或修改时间
    2. cp：复制文件
    3. mv：移动并重命名文件
    4. ln：链接文件
    5. rm：删除文件
    6. cat：打印文件内容
    7. more/less：逐页显示文件，more不可以回退，less可以回退

## 文件类型
\-：普通文件，文本或代码数据，没有特别的内部结构
d：目录
l：链接文件，软链接硬链接
s：socket 套接字
b：块特殊文件，设备以块的形式进行访问
c：字符特殊文件，设备以字符的形式进行访问
p：管道

## 文件权限
1. 文件权限可帮助您保护文件免受他人侵害系统上的用户
2. 三个访问级别：
    1. 用户：创建文件的用户
    2. 组：拥有文件的组中的所有用户
    3. 其他：其他
3. 三个权限：
    1. 读取®：读取文件内容或列表内容目录
    2. 写(w)：更改文件内容或创建/删除文件在目录中
    3. 执行(x)：以程序执行文件或使用目录作为活动目录
**更改权限：chmod**
1.  符号方式
在符号方式中，`chmod`命令的语法如下：
```
chmod [who] [+|-|=] [permissions] file
```
其中：
- `who` 表示要修改的权限对象，可以是以下字符之一：
	- `u`：表示文件所有者
	- `g`：表示文件所属组
	- `o`：表示其他用户
	- `a`：表示所有用户（等价于`ugo`）
- `+`表示添加权限，`-`表示取消权限，`=`表示设置权限。
- `permissions`表示要添加、取消或设置的权限，可以是以下字符之一：
    - `r`：表示读权限
    - `w`：表示写权限
    - `x`：表示执行权限
    - `s`：表示设置用户或组ID（SUID或SGID）
    - `t`：表示设置粘滞位
- `file`表示要修改权限的文件或目录名。
例如，要将文件`test.txt`的所有者和组的写权限添加上，可以使用以下命令：
```
chmod ug+w test.txt
```
2.  数字方式
在数字方式中，`chmod`命令的语法如下：
```
chmod [mode] file
```
其中，`mode`是一个三位八进制数，分别表示文件所有者、文件所属组和其他用户的权限。每个八进制数可以由以下三个数字的和来表示：
-   4：表示读权限
-   2：表示写权限
-   1：表示执行权限


## 目录结构
根目录下：
1.  `/boot`：内核、bootloader 的配置，包括引导加载程序相关的文件。内核的 initrd、vmlinux、grub 文件位于/boot 下。
2.  `/etc`：系统的配置文件所在地，下载软件的配置文件在也在这里，包含所有程序所需的配置文件
3.  `/bin`：程序文件夹，包含二进制可执行文件，例如`ls`，其实是在执行一个程序；也有一部分程序在`/usr/bin`(在我的linux上，/bin是/usr/bin的软链接)
4.  `/mnt`：**挂载目录**，临时挂载目录，系统管理员可以挂载文件系统。
5.  `/sbin`：系统二进制文件，但是这个目录下的Linux命令通常**由系统管理员使用，对系统进行维护**，例如`ifconfig/fdisk`也有部分程序在`/sbin`，例如分区命令`fdisk`
6.  `/usr`：资源文件夹(和编程相关的)；编译器、默认的头文件、系统中的库文件，包含二进制文件、库文件、文档和二级程序的源代码
    1.  `/usr/bin`中包含用户程序的二进制文件。`/bin`
    2.  `/usr/sbin`中包含系统管理员的二进制文件。`/sbin`
    3.  `/usr/lib`中包含了`/usr/bin`和`/usr/sbin`用到的库。
    4.  `/usr/local`中包含了从源安装的用户程序。
7.  `/lib`：系统库。包含**支持位于/bin和/sbin下的二进制文件的库文件**；库文件名为 `ld*或lib*.so.*`
8.  `/proc`：包括**系统进行相关信息**。这是一个虚拟的文件系统，包含有关正在运行的进程的信息；系统资源以文本信息形式存在。
9.  `/var`：系统里的可变数据，**变量文件**，并不是存放在磁盘上的数据，一般是存放在内存中的数据。
    1.  系统日志文件`/var/log`
    2.  包和数据库文件`/var/lib`
    3.  电子邮件`/var/mail`
    4.  打印队列`/var/spool`
    5.  锁文件`/var/lock`
    6.  多次重新启动需要的临时文件`/var/tmp`
10.  `/dev`：包含**设备文件**，这些包括终端设备、USB或连接到系统的任何设备。例如`/dev/tty1`
11.  `/tmp`：包含系统和用户创建的**临时文件**，当系统重新启动时，这个目录下的文件都将被删除。
12.  `/home`：用home目录来存储他们的个人档案。
13.  `/opt`：可选的附加应用程序
14.  `/media`：用于挂载**可移动设备**的临时目录。举例来说，挂载CD-ROM的/media/cdrom，挂载软盘驱动器的/media/floppy
15.  `/srv`：srv代表服务。包含服务器特定服务相关的数据。
16.  修改环境变量 PATH，临时修改可以直接 `PATH=$PATH:/bin`，但是要永久生效得修改配置文件 `/etc/profile`

## 重定向（重点）
在执行命令时，shell 会为每个命令打开三个文件描述符：
-   标准输入（stdin），文件描述符为0；
-   标准输出（stdout），文件描述符为1；
-   标准错误输出（stderr），文件描述符为2。
重定向实际上就是**改变这些文件描述符的指向**，使得命令的输入和输出不再是默认的终端或者窗口。具体来说，重定向时系统执行了以下操作：
1.  打开指定的文件或设备，并为其分配一个文件描述符；
2.  关闭原来与文件描述符相关联的文件或设备；
3.  将文件描述符与新的文件或设备相关联。
例如，执行以下命令：
```
ls > file.txt
```
在执行时，shell会打开`file.txt`文件，并为其分配一个文件描述符，通常是3。接着，shell关闭原来与标准输出（文件描述符为1）相关联的文件或设备，将标准输出的文件描述符与`file.txt`的文件描述符3相关联。这样，`ls`命令的标准输出就被重定向到了`file.txt`文件中。
需要注意的是，在执行命令时如果使用了重定向，可能会覆盖原来的文件内容，如果不希望覆盖，可以使用 `>>` 符号来进行追加写入。
注意文件描述符的分配：
文件描述符的值是由系统动态分配的，可以是任何可用的文件描述符。在重定向输出到一个新文件时，系统会为该文件分配一个未使用的文件描述符，通常是最小的可用文件描述符（大多数系统从 3 开始分配）。因此，在不同的上下文中，输出到新文件的文件描述符可能是不同的。
需要注意的是，如果在执行命令时使用了多个重定向操作符（如`ls > file.txt 2>&1`），则需要小心处理文件描述符的值，以免造成不必要的混淆和错误。

## 管道
在 Linux 中，管道是一种特殊的命令符号“|”，它可以将一个命令的输出直接传递给另一个命令作为输入，从而实现两个或多个命令的组合使用。使用管道可以方便地将多个命令串联起来，让它们相互协作，提高工作效率。例如，可以使用“ls | grep keyword”命令来搜索文件系统中包含指定关键字的文件。
**具体实现**
在 Linux 和 Unix 系统中，管道是通过创建一个管道文件（pipe）来实现的。管道文件是一种特殊的文件类型，它可以将一个进程的输出直接传递给另一个进程作为输入。当使用管道符号“|”将两个命令连接起来时，操作系统会自动创建一个管道文件，将前一个命令的输出写入管道文件中，然后将管道文件的内容读取到后一个命令的输入中。
具体来说，当使用“command1 | command2”命令时，操作系统会创建一个管道文件，然后创建两个子进程，一个运行command1命令，另一个运行command2命令。command1进程的输出会被写入管道文件中，command2进程则从管道文件中读取输入。这样就实现了两个命令之间的数据传递和处理。
需要注意的是，管道只能用于连接两个命令，如果需要连接多个命令，可以使用多个管道符号“|”，例如“command1 | command2 | command3”等。此外，管道只能传递标准输出（STDOUT），如果需要传递标准错误输出（STDERR），可以使用重定向符号“2>&1”将标准错误输出重定向到标准输出中，然后再使用管道进行传递。
**管道 vs 重定向**
管道和重定向都是在 Linux 和 Unix 系统中用于处理命令输入和输出的工具，它们的作用是不同的。
管道（|）是将一个命令的输出作为另一个命令的输入，用于将多个命令串联起来，实现命令之间的数据传递和处理。例如，我们可以使用“ls | grep keyword”命令来搜索文件系统中包含指定关键字的文件。
重定向（>、>>、<）是将命令的输入或输出重定向到文件中，用于控制命令的输入和输出。例如，我们可以使用“ls > file.txt”命令将ls命令的输出重定向到file.txt文件中，或者使用“sort < file.txt”命令将file.txt文件的内容作为sort命令的输入。
因此，管道和重定向都是用于处理命令输入和输出的工具，但它们的作用和使用方法是不同的。管道用于将多个命令串联起来，重定向用于控制命令的输入和输出。


## 环境变量
在计算机操作系统中，环境变量是一种存储在操作系统中的值，它们被用于指定应用程序的运行环境。环境变量可以包含各种信息，如路径、语言设置、用户名等等。在 Linux 和 Unix 系统中，环境变量通常是由 shell 进程创建和管理的，它们可以被所有进程共享。环境变量可以在命令行中设置，也可以通过编写脚本或程序进行操作。通过使用环境变量，用户可以自定义自己的工作环境，使命令行工具和应用程序更加灵活和易于使用。

